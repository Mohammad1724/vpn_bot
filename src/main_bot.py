# -*- coding: utf-8 -*-

import logging
import os
import shutil
import asyncio
import random
import sqlite3
import io
from datetime import datetime, timedelta, time
import jdatetime
from typing import Union
from functools import wraps
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
    ApplicationBuilder
)
from telegram.constants import ParseMode, ChatMemberStatus
from telegram.error import Forbidden, BadRequest
import database as db
import hiddify_api
from config import (
    BOT_TOKEN, ADMIN_ID, SUPPORT_USERNAME, SUB_DOMAINS, ADMIN_PATH,
    PANEL_DOMAIN, SUB_PATH, TRIAL_ENABLED, TRIAL_DAYS, TRIAL_GB,
    REFERRAL_BONUS_AMOUNT, EXPIRY_REMINDER_DAYS, FORCE_JOIN_CHANNELS, USAGE_ALERT_THRESHOLD
)
import qrcode

# --- Setup ---
os.makedirs('backups', exist_ok=True)
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("bot.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# --- Constants & States ---
BTN_ADMIN_PANEL = "ğŸ‘‘ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†"
BTN_EXIT_ADMIN_PANEL = "â†©ï¸ Ø®Ø±ÙˆØ¬ Ø§Ø² Ù¾Ù†Ù„"
BTN_BACK_TO_ADMIN_MENU = "Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§Ø¯Ù…ÛŒÙ†"
CMD_CANCEL = "/cancel"
CMD_SKIP = "/skip"
(
    ADMIN_MENU, PLAN_MENU, REPORTS_MENU, USER_MANAGEMENT_MENU, PLAN_NAME,
    PLAN_PRICE, PLAN_DAYS, PLAN_GB, EDIT_PLAN_NAME, EDIT_PLAN_PRICE,
    EDIT_PLAN_DAYS, EDIT_PLAN_GB, MANAGE_USER_ID, MANAGE_USER_ACTION,
    MANAGE_USER_AMOUNT, GET_CUSTOM_NAME, REDEEM_GIFT, CHARGE_AMOUNT,
    CHARGE_RECEIPT, SETTINGS_MENU, BACKUP_MENU, BROADCAST_MENU, BROADCAST_MESSAGE,
    BROADCAST_CONFIRM, BROADCAST_TO_USER_ID, BROADCAST_TO_USER_MESSAGE, RESTORE_UPLOAD,
    AWAIT_SETTING_VALUE, REPORT_CUSTOM_DATE_START, REPORT_CUSTOM_DATE_END
) = range(30)


# --- Force Join Decorator ---
def check_channel_membership(func):
    @wraps(func)
    async def wrapped(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        if not FORCE_JOIN_CHANNELS:
            return await func(update, context, *args, **kwargs)

        user_id = update.effective_user.id
        if user_id == ADMIN_ID:
            return await func(update, context, *args, **kwargs)

        not_joined_channels = []
        for channel in FORCE_JOIN_CHANNELS:
            try:
                member = await context.bot.get_chat_member(chat_id=channel, user_id=user_id)
                if member.status not in [ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]:
                    not_joined_channels.append(channel)
            except (BadRequest, Forbidden) as e:
                logger.error(f"Error checking membership for channel {channel}: {e}")
                not_joined_channels.append(channel)
        
        if not_joined_channels:
            keyboard = []
            text = "Ú©Ø§Ø±Ø¨Ø± Ú¯Ø±Ø§Ù…ÛŒØŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ø¨Ø§Øª Ù„Ø§Ø²Ù… Ø§Ø³Øª Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n\n"
            for i, channel in enumerate(not_joined_channels, 1):
                try:
                    chat = await context.bot.get_chat(channel)
                    invite_link = chat.invite_link or f"https://t.me/{chat.username}"
                    text += f"{i}- {chat.title}\n"
                    keyboard.append([InlineKeyboardButton(f"Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ {chat.title}", url=invite_link)])
                except Exception as e:
                    logger.error(f"Could not get info for channel {channel}: {e}")
            
            keyboard.append([InlineKeyboardButton("âœ… Ø¹Ø¶Ùˆ Ø´Ø¯Ù…", callback_data="check_join")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if update.callback_query:
                await update.callback_query.answer("Ù„Ø·ÙØ§ Ø§Ø¨ØªØ¯Ø§ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯.", show_alert=True)
                if update.effective_message.photo:
                    await update.effective_message.reply_text(text, reply_markup=reply_markup)
                else:
                    await update.effective_message.edit_text(text, reply_markup=reply_markup)
            else:
                await update.message.reply_text(text, reply_markup=reply_markup)
            return

        return await func(update, context, *args, **kwargs)
    return wrapped

# --- Keyboards ---
def get_main_menu_keyboard(user_id):
    user_info = db.get_or_create_user(user_id)
    keyboard = [
        ["ğŸ›ï¸ Ø®Ø±ÛŒØ¯ Ø³Ø±ÙˆÛŒØ³", "ğŸ“‹ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…Ù†"],
        ["ğŸ‘¤ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø¨", "ğŸ Ú©Ø¯ Ù‡Ø¯ÛŒÙ‡"],
        ["ğŸ Ù…Ø¹Ø±ÙÛŒ Ø¯ÙˆØ³ØªØ§Ù†"]
    ]
    if TRIAL_ENABLED and user_info and not user_info.get('has_used_trial'):
        keyboard.insert(2, ["ğŸ§ª Ø¯Ø±ÛŒØ§ÙØª Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª Ø±Ø§ÛŒÚ¯Ø§Ù†"])
    keyboard.append(["ğŸ“ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", "ğŸ“š Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§ØªØµØ§Ù„"])
    if user_id == ADMIN_ID:
        keyboard.append([BTN_ADMIN_PANEL])
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

def get_admin_menu_keyboard():
    keyboard = [
        ["â• Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ù„Ù†â€ŒÙ‡Ø§", "ğŸ“ˆ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ Ùˆ Ø¢Ù…Ø§Ø±"],
        ["âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª", "ğŸ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø¯ Ù‡Ø¯ÛŒÙ‡"],
        ["ğŸ“© Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…", "ğŸ’¾ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ"],
        ["ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†"],
        ["ğŸ›‘ Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª", BTN_EXIT_ADMIN_PANEL]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

# --- Helper Functions ---
def _parse_date_flexible(date_str: str) -> Union[datetime.date, None]:
    if not date_str:
        return None
    date_part = date_str.split('T')[0]
    formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
    for fmt in formats_to_try:
        try:
            return datetime.strptime(date_part, fmt).date()
        except (ValueError, TypeError):
            continue
    logger.error(f"Could not parse date string '{date_str}' with any known format.")
    return None

async def _get_service_status(hiddify_info):
    date_keys = ['start_date', 'last_reset_time', 'created_at']
    start_date_str = next((hiddify_info.get(key) for key in date_keys if hiddify_info.get(key)), None)
    package_days = hiddify_info.get('package_days', 0)
    if not start_date_str:
        logger.warning(f"Could not find a valid date key in Hiddify info: {hiddify_info}")
        return "âš ï¸ ÙˆØ¶Ø¹ÛŒØª Ù†Ø§Ù…Ø´Ø®Øµ", "N/A", True
    start_date_obj = _parse_date_flexible(start_date_str)
    if not start_date_obj:
        return "âš ï¸ ÙˆØ¶Ø¹ÛŒØª Ù†Ø§Ù…Ø´Ø®Øµ", "N/A", True
    expiry_date_obj = start_date_obj + timedelta(days=package_days)
    jalali_expiry_date = jdatetime.date.fromgregorian(date=expiry_date_obj)
    jalali_display_str = jalali_expiry_date.strftime("%Y/%m/%d")
    is_expired = expiry_date_obj < datetime.now().date()
    status = "ğŸ”´ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡" if is_expired else "ğŸŸ¢ ÙØ¹Ø§Ù„"
    return status, jalali_display_str, is_expired

def is_valid_sqlite(filepath):
    try:
        with sqlite3.connect(filepath) as conn:
            cursor = conn.cursor()
            cursor.execute("PRAGMA integrity_check;")
            result = cursor.fetchone()
        return result[0] == 'ok'
    except sqlite3.DatabaseError:
        return False

# --- Background Jobs ---
async def check_low_usage(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Running job: Checking for low usage services...")
    all_services = db.get_all_active_services()
    for service in all_services:
        if service['low_usage_alert_sent']:
            continue
        try:
            info = await hiddify_api.get_user_info(service['sub_uuid'])
            if not info:
                logger.warning(f"Could not get info for service {service['service_id']} during usage check.")
                continue

            status, expiry_date, is_expired = await _get_service_status(info)
            if is_expired:
                continue

            usage_limit = info.get('usage_limit_GB', 0)
            current_usage = info.get('current_usage_GB', 0)

            if usage_limit > 0 and (current_usage / usage_limit) >= USAGE_ALERT_THRESHOLD:
                user_id = service['user_id']
                service_name = f"'{service['name']}'" if service['name'] else ""
                await context.bot.send_message(
                    chat_id=user_id,
                    text=(
                        f"ğŸ“¢ Ù‡Ø´Ø¯Ø§Ø± Ø§ØªÙ…Ø§Ù… Ø­Ø¬Ù…!\n\n"
                        f"Ú©Ø§Ø±Ø¨Ø± Ú¯Ø±Ø§Ù…ÛŒØŒ Ø¨ÛŒØ´ Ø§Ø² {int(USAGE_ALERT_THRESHOLD * 100)}Ùª Ø§Ø² Ø­Ø¬Ù… Ø³Ø±ÙˆÛŒØ³ Ø´Ù…Ø§ {service_name} Ù…ØµØ±Ù Ø´Ø¯Ù‡ Ø§Ø³Øª.\n"
                        f"({current_usage:.2f} Ú¯ÛŒÚ¯ Ø§Ø² {usage_limit:.0f} Ú¯ÛŒÚ¯)\n\n"
                        "Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù‚Ø·Ø¹ÛŒØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ø³Ø±ÙˆÛŒØ³ Ø®ÙˆØ¯ Ø±Ø§ ØªÙ…Ø¯ÛŒØ¯ Ù†Ù…Ø§ÛŒÛŒØ¯."
                    )
                )
                db.set_low_usage_alert_sent(service['service_id'])
                logger.info(f"Sent low usage alert to user {user_id} for service {service['service_id']}.")
                await asyncio.sleep(0.2)
        except (Forbidden, BadRequest) as e:
            logger.warning(f"Failed to send low usage alert to user {service['user_id']}: {e}")
        except Exception as e:
            logger.error(f"An unexpected error in low usage job for service {service['service_id']}: {e}", exc_info=True)

async def check_expiring_services(context: ContextTypes.DEFAULT_TYPE):
    logger.info("Running job: Checking for expiring services...")
    all_services = db.get_all_active_services()
    for service in all_services:
        try:
            info = await hiddify_api.get_user_info(service['sub_uuid'])
            if not info:
                continue

            _, expiry_date_str, is_expired = await _get_service_status(info)
            if is_expired or expiry_date_str == "N/A":
                continue
            
            parts = expiry_date_str.split('/')
            jalali_date = jdatetime.date(int(parts[0]), int(parts[1]), int(parts[2]))
            gregorian_expiry_date = jalali_date.togregorian()
            
            days_left = (gregorian_expiry_date - datetime.now().date()).days

            if days_left == EXPIRY_REMINDER_DAYS:
                user_id = service['user_id']
                service_name = f"'{service['name']}'" if service['name'] else ""
                
                await context.bot.send_message(
                    chat_id=user_id,
                    text=(
                        f"â³ **ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³**\n\n"
                        f"Ú©Ø§Ø±Ø¨Ø± Ú¯Ø±Ø§Ù…ÛŒØŒ ØªÙ†Ù‡Ø§ **{days_left} Ø±ÙˆØ²** ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø§Ø¹ØªØ¨Ø§Ø± Ø³Ø±ÙˆÛŒØ³ Ø´Ù…Ø§ {service_name} Ø¨Ø§Ù‚ÛŒ Ù…Ø§Ù†Ø¯Ù‡ Ø§Ø³Øª.\n\n"
                        f"Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù‚Ø·Ø¹ÛŒØŒ Ù„Ø·ÙØ§Ù‹ Ø³Ø±ÙˆÛŒØ³ Ø®ÙˆØ¯ Ø±Ø§ ØªÙ…Ø¯ÛŒØ¯ Ù†Ù…Ø§ÛŒÛŒØ¯."
                    )
                )
                logger.info(f"Sent expiry reminder to user {user_id} for service {service['service_id']}.")
                await asyncio.sleep(0.2)
        except (Forbidden, BadRequest) as e:
            logger.warning(f"Failed to send expiry reminder to user {service['user_id']}: {e}")
        except Exception as e:
            logger.error(f"An unexpected error in expiry reminder job for service {service['service_id']}: {e}", exc_info=True)
            
# --- Generic Handlers ---
@check_channel_membership
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    db.get_or_create_user(user.id, user.username)
    
    if context.args and context.args[0].startswith('ref_'):
        try:
            referrer_id = int(context.args[0].split('_')[1])
            if referrer_id != user.id:
                db.set_referrer(user.id, referrer_id)
        except (ValueError, IndexError):
            logger.warning(f"Invalid referral link used: {context.args[0]}")

    user_info = db.get_user(user.id)
    if user_info and user_info.get('is_banned'):
        await update.effective_message.reply_text("Ø´Ù…Ø§ Ø§Ø² Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† Ø±Ø¨Ø§Øª Ù…Ù†Ø¹ Ø´Ø¯Ù‡â€ŒØ§ÛŒØ¯.")
        return ConversationHandler.END
        
    await update.effective_message.reply_text("ğŸ‘‹ Ø¨Ù‡ Ø±Ø¨Ø§Øª ÙØ±ÙˆØ´ VPN Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!", reply_markup=get_main_menu_keyboard(user.id))
    return ConversationHandler.END

async def check_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.delete()
    await start(query, context)

async def admin_generic_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.", reply_markup=get_admin_menu_keyboard())
    return ADMIN_MENU

async def admin_conv_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.", reply_markup=get_admin_menu_keyboard())
    return ConversationHandler.END

async def user_generic_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.", reply_markup=get_main_menu_keyboard(update.effective_user.id))
    return ConversationHandler.END

# --- User Service Management ---
@check_channel_membership
async def list_my_services(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    message = update.effective_message
    
    services = db.get_user_services(user_id)
    if not services:
        await message.reply_text("Ø´Ù…Ø§ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ù‡ÛŒÚ† Ø³Ø±ÙˆÛŒØ³ ÙØ¹Ø§Ù„ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.")
        return
    
    keyboard = []
    for service in services:
        button_text = f"âš™ï¸ {service['name']}"
        callback_data = f"view_service_{service['service_id']}"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await message.edit_text("Ù„Ø·ÙØ§ Ø³Ø±ÙˆÛŒØ³ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù…Ø¯ÛŒØ±ÛŒØªØ´ Ú©Ù†ÛŒØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ù…Ø§ÛŒÛŒØ¯:", reply_markup=reply_markup)
    else:
        await message.reply_text("Ù„Ø·ÙØ§ Ø³Ø±ÙˆÛŒØ³ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù…Ø¯ÛŒØ±ÛŒØªØ´ Ú©Ù†ÛŒØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ù…Ø§ÛŒÛŒØ¯:", reply_markup=reply_markup)

@check_channel_membership
async def view_service_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    service_id = int(query.data.split('_')[-1])
    
    service = db.get_service(service_id)
    if not service:
        await query.edit_message_text("âŒ Ø³Ø±ÙˆÛŒØ³ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        return

    await show_link_options_menu(query.message, service['sub_uuid'], service_id=service['service_id'], is_edit=True)

async def show_link_options_menu(message: Update.message, user_uuid: str, service_id: int, is_edit: bool = True):
    admin_recommendation_text = " (Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø§Ø¯Ù…ÛŒÙ†)"
    keyboard = [
        [InlineKeyboardButton(f"ğŸ”— Ù„ÛŒÙ†Ú© Ù‡ÙˆØ´Ù…Ù†Ø¯ (Auto){admin_recommendation_text}", callback_data=f"getlink_auto_{user_uuid}")],
        [InlineKeyboardButton("ğŸ’» Ù„ÛŒÙ†Ú© Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (Sub)", callback_data=f"getlink_sub_{user_uuid}")],
        [InlineKeyboardButton("ğŸ“± Ù„ÛŒÙ†Ú© Clash", callback_data=f"getlink_clash_{user_uuid}")],
        [InlineKeyboardButton("ğŸ’¥ Ù„ÛŒÙ†Ú© Clash Meta", callback_data=f"getlink_clashmeta_{user_uuid}")],
        [InlineKeyboardButton("âš¡ï¸ Ù„ÛŒÙ†Ú© Xray", callback_data=f"getlink_xray_{user_uuid}")],
        [InlineKeyboardButton("âš™ï¸ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ ØªÚ©ÛŒ", callback_data=f"single_configs_{service_id}")],
    ]
    
    if is_edit:
        keyboard.append([InlineKeyboardButton("â¬…ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù„ÛŒØ³Øª Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§", callback_data="back_to_services")])

    text = "Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    try:
        if is_edit:
            await message.edit_text(text, reply_markup=reply_markup)
        else:
            await message.reply_text(text, reply_markup=reply_markup)
    except BadRequest as e:
        if "message is not modified" not in str(e):
            logger.error(f"Error in show_link_options_menu: {e}")

async def get_link_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    _, link_type, user_uuid = query.data.split('_')
    
    await query.edit_message_text("Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ù„ÛŒÙ†Ú© Ùˆ QR Code... â³")
    
    sub_path = SUB_PATH or ADMIN_PATH
    sub_domain = random.choice(SUB_DOMAINS) if SUB_DOMAINS else PANEL_DOMAIN
    base_link = f"https://{sub_domain}/{sub_path}/{user_uuid}"
    
    user_info = await hiddify_api.get_user_info(user_uuid)
    config_name = user_info.get('name', 'config') if user_info else 'config'
    
    suffix_map = {
        "auto": "/", "sub": "/sub/", "clash": "/clash/", "clashmeta": "/clashmeta/", "xray": "/xray/",
    }
    link_suffix = suffix_map.get(link_type, "/")
    final_link = f"{base_link}{link_suffix}"
    final_link_with_fragment = f"{final_link}?name={config_name.replace(' ', '_')}"
    
    qr_image = qrcode.make(final_link_with_fragment)
    bio = io.BytesIO(); bio.name = 'qrcode.png'; qr_image.save(bio, 'PNG'); bio.seek(0)
    
    caption = (f"Ù†Ø§Ù… Ú©Ø§Ù†ÙÛŒÚ¯: **{config_name}**\n\n"
               "Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø§ Ø§Ø³Ú©Ù† QR Ú©Ø¯ Ø²ÛŒØ± ÛŒØ§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú©ØŒ Ø¨Ù‡ Ø³Ø±ÙˆÛŒØ³ Ù…ØªØµÙ„ Ø´ÙˆÛŒØ¯.\n\n"
               f"Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© Ø´Ù…Ø§:\n`{final_link_with_fragment}`")
               
    await query.message.delete()

    service = db.get_service_by_uuid(user_uuid)
    keyboard = [[InlineKeyboardButton("â¬…ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ù„ÛŒÙ†Ú©", callback_data=f"view_service_{service['service_id']}")]]

    await context.bot.send_photo(
        chat_id=query.message.chat_id,
        photo=bio,
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def show_single_configs_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    _, service_id_str = query.data.split('_')
    service_id = int(service_id_str)

    service = db.get_service(service_id)
    if not service:
        await query.edit_message_text("âŒ Ø³Ø±ÙˆÛŒØ³ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        return

    await query.edit_message_text("Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ ØªÚ©ÛŒ...")
    info = await hiddify_api.get_user_info(service['sub_uuid'])
    if not info:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø² Ù¾Ù†Ù„.")
        return

    keyboard = []
    if info.get('vless_link'):
        keyboard.append([InlineKeyboardButton("VLESS", callback_data=f"get_single_vless_{service_id}")])
    if info.get('vmess_link'):
        keyboard.append([InlineKeyboardButton("VMess", callback_data=f"get_single_vmess_{service_id}")])
    if info.get('trojan_link'):
        keyboard.append([InlineKeyboardButton("Trojan", callback_data=f"get_single_trojan_{service_id}")])

    if not keyboard:
        await query.edit_message_text("Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ ØªÚ©ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³Ø±ÙˆÛŒØ³ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        return
        
    keyboard.append([InlineKeyboardButton("â¬…ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ÛŒ Ø§Ø´ØªØ±Ø§Ú©", callback_data=f"view_service_{service_id}")])
    
    await query.edit_message_text("Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ú©Ø§Ù†ÙÛŒÚ¯ ØªÚ©ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:", reply_markup=InlineKeyboardMarkup(keyboard))

async def get_single_config(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    _, config_type, service_id_str = query.data.split('_')
    service_id = int(service_id_str)
    
    service = db.get_service(service_id)
    if not service:
        await query.edit_message_text("âŒ Ø³Ø±ÙˆÛŒØ³ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        return

    await query.edit_message_text("Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ú©Ø§Ù†ÙÛŒÚ¯ Ùˆ QR Ú©Ø¯... â³")
    info = await hiddify_api.get_user_info(service['sub_uuid'])
    
    config_key = f"{config_type}_link"
    single_config_link = info.get(config_key)

    if not single_config_link:
        await query.edit_message_text(f"âŒ Ú©Ø§Ù†ÙÛŒÚ¯ {config_type.upper()} ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        return

    qr_image = qrcode.make(single_config_link)
    bio = io.BytesIO(); bio.name = 'qrcode.png'; qr_image.save(bio, 'PNG'); bio.seek(0)

    caption = (
        f"Ú©Ø§Ù†ÙÛŒÚ¯ ØªÚ©ÛŒ **{config_type.upper()}** Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³ **{service['name']}**\n\n"
        "Ø¨Ø§ Ø§Ø³Ú©Ù† QR Ú©Ø¯ ÛŒØ§ Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† Ù…ØªÙ† Ø²ÛŒØ±ØŒ Ú©Ø§Ù†ÙÛŒÚ¯ Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯:\n\n"
        f"`{single_config_link}`"
    )
    
    await query.message.delete()
    
    keyboard = [[InlineKeyboardButton("â¬…ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ù†ÙÛŒÚ¯ ØªÚ©ÛŒ", callback_data=f"single_configs_{service_id}")]]
    
    await context.bot.send_photo(
        chat_id=query.message.chat_id,
        photo=bio,
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

@check_channel_membership
async def back_to_services_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.delete()
    await list_my_services(query, context)

# --- Renewal Logic ---
@check_channel_membership
async def renew_service_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.delete()
    
    service_id = int(query.data.split('_')[1])
    user_id = query.from_user.id
    service = db.get_service(service_id)
    if not service: await context.bot.send_message(chat_id=user_id, text="âŒ Ø³Ø±ÙˆÛŒØ³ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª."); return
    plan = db.get_plan(service['plan_id'])
    if not plan: await context.bot.send_message(chat_id=user_id, text="âŒ Ù¾Ù„Ù† ØªÙ…Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³Ø±ÙˆÛŒØ³ ÛŒØ§ÙØª Ù†Ø´Ø¯."); return
    user = db.get_or_create_user(user_id)
    if user['balance'] < plan['price']: await context.bot.send_message(chat_id=user_id, text=f"Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙ…Ø¯ÛŒØ¯ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª! (Ù†ÛŒØ§Ø² Ø¨Ù‡ {plan['price']:.0f} ØªÙˆÙ…Ø§Ù†)"); return

    msg = await context.bot.send_message(chat_id=user_id, text="Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³Ø±ÙˆÛŒØ³... â³")
    hiddify_info = await hiddify_api.get_user_info(service['sub_uuid'])
    if not hiddify_info: await msg.edit_text("âŒ Ø§Ù…Ú©Ø§Ù† Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø³Ø±ÙˆÛŒØ³ Ø§Ø² Ù¾Ù†Ù„ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯."); return
    
    _, _, is_expired = await _get_service_status(hiddify_info)
    context.user_data['renewal_service_id'] = service_id
    context.user_data['renewal_plan_id'] = plan['plan_id']
    
    if is_expired:
        await proceed_with_renewal(update, context, original_message=msg)
    else:
        keyboard = [[InlineKeyboardButton("âœ… Ø¨Ù„Ù‡ØŒ ØªÙ…Ø¯ÛŒØ¯ Ú©Ù†", callback_data=f"confirmrenew")], [InlineKeyboardButton("âŒ Ø®ÛŒØ±ØŒ Ù„ØºÙˆ Ú©Ù†", callback_data=f"cancelrenew")]]
        await msg.edit_text("âš ï¸ **Ù‡Ø´Ø¯Ø§Ø± Ù…Ù‡Ù…** âš ï¸\n\nØ³Ø±ÙˆÛŒØ³ Ø´Ù…Ø§ Ù‡Ù†ÙˆØ² Ø§Ø¹ØªØ¨Ø§Ø± Ø¯Ø§Ø±Ø¯. ØªÙ…Ø¯ÛŒØ¯ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ø§Ø¹ØªØ¨Ø§Ø± Ø²Ù…Ø§Ù†ÛŒ Ùˆ Ø­Ø¬Ù…ÛŒ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡ Ø´Ù…Ø§ **Ø§Ø² Ø¨ÛŒÙ† Ø¨Ø±ÙˆØ¯** Ùˆ Ø¯ÙˆØ±Ù‡ Ø¬Ø¯ÛŒØ¯ Ø§Ø² Ù‡Ù…ÛŒÙ† Ø§Ù…Ø±ÙˆØ² Ø´Ø±ÙˆØ¹ Ø´ÙˆØ¯.\n\nØ¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯?", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)

@check_channel_membership
async def confirm_renewal_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await proceed_with_renewal(update, context, original_message=query.message)

async def proceed_with_renewal(update: Update, context: ContextTypes.DEFAULT_TYPE, original_message=None):
    query = update.callback_query
    user_id = query.from_user.id if query else update.effective_user.id
    
    service_id = context.user_data.get('renewal_service_id')
    plan_id = context.user_data.get('renewal_plan_id')
    
    if not all([service_id, plan_id]):
        if original_message: await original_message.edit_text("âŒ Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ: Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙ…Ø¯ÛŒØ¯ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
        return

    if original_message: await original_message.edit_text("Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªÙ…Ø¯ÛŒØ¯ Ø¨Ù‡ Ù¾Ù†Ù„... â³")
    
    transaction_id = db.initiate_renewal_transaction(user_id, service_id, plan_id)
    if not transaction_id:
        if original_message: await original_message.edit_text("âŒ Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ ØªÙ…Ø¯ÛŒØ¯ Ù¾ÛŒØ´ Ø¢Ù…Ø¯ (Ù…Ø«Ù„Ø§ Ø¹Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ÛŒ).")
        return

    service = db.get_service(service_id)
    plan = db.get_plan(plan_id)

    logger.info(f"Attempting to renew service {service_id} for user {user_id} with UUID {service['sub_uuid']}")
    logger.info(f"Renewal details: Plan ID {plan_id}, Days: {plan['days']}, GB: {plan['gb']}")

    new_hiddify_info = await hiddify_api.renew_user_subscription(service['sub_uuid'], plan['days'], plan['gb'])
    logger.info(f"Hiddify renewal API returned: {new_hiddify_info}")

    if new_hiddify_info:
        db.finalize_renewal_transaction(transaction_id, plan_id)
        if original_message: 
            await original_message.edit_text("âœ… Ø³Ø±ÙˆÛŒØ³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙ…Ø¯ÛŒØ¯ Ø´Ø¯! Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ù„ÛŒÙ†Ú© Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯...")
            # We need to create a dummy query object to pass to view_service_callback
            from unittest.mock import Mock
            mock_query = Mock()
            mock_query.data = f"view_service_{service_id}"
            mock_query.message = original_message
            mock_query.answer = asyncio.coroutine(lambda: None)
            mock_update = Mock(callback_query=mock_query)
            await view_service_callback(mock_update, context)
        else:
            await context.bot.send_message(chat_id=user_id, text="âœ… Ø³Ø±ÙˆÛŒØ³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙ…Ø¯ÛŒØ¯ Ø´Ø¯!")
    else:
        db.cancel_renewal_transaction(transaction_id)
        if original_message: await original_message.edit_text("âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙ…Ø¯ÛŒØ¯ Ø³Ø±ÙˆÛŒØ³. Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ù¾Ù†Ù„ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ù‡ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹ Ø¯Ù‡ÛŒØ¯.")
        
    context.user_data.clear()

@check_channel_membership
async def cancel_renewal_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Ø¹Ù…Ù„ÛŒØ§Øª ØªÙ…Ø¯ÛŒØ¯ Ù„ØºÙˆ Ø´Ø¯.")
    context.user_data.clear()

# --- Main User Flow Handlers ---
@check_channel_membership
async def show_account_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_info = db.get_user(user_id)
    purchase_stats = db.get_user_purchase_stats(user_id)
    
    join_date_gregorian = _parse_date_flexible(user_info['join_date'])
    join_date_jalali = "N/A"
    if join_date_gregorian:
        jalali_date = jdatetime.date.fromgregorian(date=join_date_gregorian)
        join_date_jalali = jalali_date.strftime("%Y/%m/%d")

    text = (
        f"ğŸ‘¤ **Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§**\n\n"
        f"â–«ï¸ Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ: `{user_id}`\n"
        f"ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„: **{user_info['balance']:,.0f} ØªÙˆÙ…Ø§Ù†**\n\n"
        f"ğŸ“ˆ **Ø¢Ù…Ø§Ø± Ø®Ø±ÛŒØ¯ Ø´Ù…Ø§:**\n"
        f"- ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø®Ø±ÛŒØ¯Ù‡Ø§: {purchase_stats['total_purchases']} Ø¹Ø¯Ø¯\n"
        f"- Ù…Ø¬Ù…ÙˆØ¹ Ù…Ø¨Ù„Øº Ø®Ø±ÛŒØ¯Ù‡Ø§: {purchase_stats['total_spent']:,.0f} ØªÙˆÙ…Ø§Ù†\n\n"
        f"ğŸ—“ï¸ ØªØ§Ø±ÛŒØ® Ø¹Ø¶ÙˆÛŒØª Ø´Ù…Ø§ Ø¯Ø± Ø±Ø¨Ø§Øª: {join_date_jalali}"
    )

    keyboard = [[InlineKeyboardButton("ğŸ’³ Ø´Ø§Ø±Ú˜ Ø­Ø³Ø§Ø¨", callback_data="user_start_charge")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@check_channel_membership
async def show_support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"Ø¬Ù‡Øª Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø¨Ù‡ Ø¢ÛŒØ¯ÛŒ Ø²ÛŒØ± Ù¾ÛŒØ§Ù… Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n@{SUPPORT_USERNAME}")

@check_channel_membership
async def show_guide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§:\n\n(Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¢Ù…ÙˆØ²Ø´â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù… Ø±Ø§ Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯)")

@check_channel_membership
async def show_referral_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    bot_username = (await context.bot.get_me()).username
    referral_link = f"https://t.me/{bot_username}?start=ref_{user_id}"
    
    bonus = REFERRAL_BONUS_AMOUNT
    
    text = (
        f"ğŸ **Ø¯ÙˆØ³ØªØ§Ù† Ø®ÙˆØ¯ Ø±Ø§ Ø¯Ø¹ÙˆØª Ú©Ù†ÛŒØ¯ Ùˆ Ù‡Ø¯ÛŒÙ‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯!**\n\n"
        f"Ø¨Ø§ Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯, Ø¯ÙˆØ³ØªØ§Ù† Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø¯Ø¹ÙˆØª Ú©Ù†ÛŒØ¯.\n\n"
        f"ğŸ”— **Ù„ÛŒÙ†Ú© Ø´Ù…Ø§:**\n`{referral_link}`\n\n"
        f"Ù‡Ø± Ø¯ÙˆØ³ØªÛŒ Ú©Ù‡ Ø¨Ø§ Ù„ÛŒÙ†Ú© Ø´Ù…Ø§ ÙˆØ§Ø±Ø¯ Ø±Ø¨Ø§Øª Ø´ÙˆØ¯ Ùˆ Ø§ÙˆÙ„ÛŒÙ† Ø®Ø±ÛŒØ¯ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡Ø¯, "
        f"**{bonus:,.0f} ØªÙˆÙ…Ø§Ù†** Ù‡Ø¯ÛŒÙ‡ Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø´Ù…Ø§ Ùˆ **{bonus:,.0f} ØªÙˆÙ…Ø§Ù†** Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯ÙˆØ³ØªØªØ§Ù† Ø§Ø¶Ø§ÙÙ‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯!"
    )
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

@check_channel_membership
async def get_trial_service(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_info = db.get_or_create_user(user_id, update.effective_user.username)
    if not TRIAL_ENABLED: await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª ÙØ¹Ø§Ù„ Ù†Ù…ÛŒâ€ŒØ¨Ø§Ø´Ø¯."); return
    if user_info.get('has_used_trial'): await update.message.reply_text("Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø² Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯."); return
    msg_loading = await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª Ø´Ù…Ø§... â³")
    result = await hiddify_api.create_hiddify_user(TRIAL_DAYS, TRIAL_GB, user_id, custom_name="Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª")
    if result and result.get('uuid'):
        db.set_user_trial_used(user_id)
        service = db.add_active_service(user_id, "Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª", result['uuid'], result['full_link'], 0)
        await msg_loading.delete()
        await show_link_options_menu(update.message, result['uuid'], service['service_id'], is_edit=False)
    else: await msg_loading.edit_text("âŒ Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø¯Ø± Ø³Ø§Ø®Øª Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø¢Ù…Ø¯. Ù„Ø·ÙØ§ Ø¨Ø¹Ø¯Ø§Ù‹ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")

# --- Gift Code Conversation ---
@check_channel_membership
async def gift_code_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ Ù„Ø·ÙØ§ Ú©Ø¯ Ù‡Ø¯ÛŒÙ‡ Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:", reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True))
    return REDEEM_GIFT

async def redeem_gift_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    code = update.message.text.upper()
    user_id = update.effective_user.id
    amount = db.use_gift_code(code, user_id)
    if amount is not None: await update.message.reply_text(f"âœ… ØªØ¨Ø±ÛŒÚ©! Ù…Ø¨Ù„Øº {amount:.0f} ØªÙˆÙ…Ø§Ù† Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.", reply_markup=get_main_menu_keyboard(user_id))
    else: await update.message.reply_text("âŒ Ú©Ø¯ Ù‡Ø¯ÛŒÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª.", reply_markup=get_main_menu_keyboard(user_id))
    return ConversationHandler.END

# --- Charge Account Conversation ---
@check_channel_membership
async def charge_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù…Ø¨Ù„ØºÛŒ Ú©Ù‡ Ù‚ØµØ¯ ÙˆØ§Ø±ÛŒØ² Ø¢Ù† Ø±Ø§ Ø¯Ø§Ø±ÛŒØ¯ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÙÙ‚Ø· Ø¹Ø¯Ø¯):", reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True))
    return CHARGE_AMOUNT

async def charge_amount_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        amount = int(update.message.text)
        if amount < 1000: raise ValueError
        context.user_data['charge_amount'] = amount
        card_number = db.get_setting('card_number') or "[ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡]"
        card_holder = db.get_setting('card_holder') or "[ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡]"
        await update.message.reply_text(f"Ù„Ø·ÙØ§Ù‹ Ù…Ø¨Ù„Øº **{amount:,} ØªÙˆÙ…Ø§Ù†** Ø±Ø§ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª Ø²ÛŒØ± ÙˆØ§Ø±ÛŒØ² Ù†Ù…Ø§ÛŒÛŒØ¯:\n\n`{card_number}`\nØ¨Ù‡ Ù†Ø§Ù…: {card_holder}\n\nØ³Ù¾Ø³ Ø§Ø² Ø±Ø³ÛŒØ¯ ÙˆØ§Ø±ÛŒØ²ÛŒ Ø®ÙˆØ¯ Ø¹Ú©Ø³ Ú¯Ø±ÙØªÙ‡ Ùˆ Ø¢Ù† Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.", parse_mode=ParseMode.MARKDOWN, reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True))
        return CHARGE_RECEIPT
    except (ValueError, TypeError):
        await update.message.reply_text("Ù„Ø·ÙØ§ ÛŒÚ© Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­ Ùˆ Ø¨ÛŒØ´ØªØ± Ø§Ø² 1000 ØªÙˆÙ…Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.")
        return CHARGE_AMOUNT

async def charge_receipt_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    amount = context.user_data.get('charge_amount')
    if not amount:
        await update.message.reply_text("Ø®Ø·Ø§! Ù…Ø¨Ù„Øº Ø´Ø§Ø±Ú˜ Ù…Ø´Ø®Øµ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§ Ø§Ø² Ø§Ø¨ØªØ¯Ø§ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒØ¯.", reply_markup=get_main_menu_keyboard(user.id))
        return ConversationHandler.END
    receipt_photo = update.message.photo[-1]
    caption = (f"Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ø§Ø±Ú˜ Ø¬Ø¯ÛŒØ¯ ğŸ””\n\n" f"Ú©Ø§Ø±Ø¨Ø±: {user.full_name} (@{user.username or 'N/A'})\n" f"Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ: `{user.id}`\n" f"Ù…Ø¨Ù„Øº Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ: **{amount:,} ØªÙˆÙ…Ø§Ù†**")
    keyboard = [[InlineKeyboardButton("âœ… ØªØ§ÛŒÛŒØ¯ Ø´Ø§Ø±Ú˜", callback_data=f"admin_confirm_charge_{user.id}_{int(amount)}"), InlineKeyboardButton("âŒ Ø±Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª", callback_data=f"admin_reject_charge_{user.id}")]]
    await context.bot.send_photo(chat_id=ADMIN_ID, photo=receipt_photo.file_id, caption=caption, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)
    await update.message.reply_text("âœ… Ø±Ø³ÛŒØ¯ Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ ØªØ§ Ø²Ù…Ø§Ù† Ø¨Ø±Ø±Ø³ÛŒ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯.", reply_markup=get_main_menu_keyboard(user.id))
    context.user_data.clear()
    return ConversationHandler.END

# --- Buy Service Conversation ---
@check_channel_membership
async def buy_service_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    plans = db.list_plans(only_visible=True)
    if not plans: await update.message.reply_text("Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ù‡ÛŒÚ† Ù¾Ù„Ù†ÛŒ Ø¨Ø±Ø§ÛŒ ÙØ±ÙˆØ´ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª."); return
    keyboard = [[InlineKeyboardButton(f"{p['name']} - {p['days']} Ø±ÙˆØ²Ù‡ {p['gb']} Ú¯ÛŒÚ¯ - {p['price']:.0f} ØªÙˆÙ…Ø§Ù†", callback_data=f"user_buy_{p['plan_id']}")] for p in plans]
    await update.message.reply_text("Ù„Ø·ÙØ§ Ø³Ø±ÙˆÛŒØ³ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:", reply_markup=InlineKeyboardMarkup(keyboard))

async def create_service_after_name(message: Update.message, context: ContextTypes.DEFAULT_TYPE):
    user_id = message.chat_id
    plan_id = context.user_data.get('plan_to_buy_id')
    transaction_id = context.user_data.get('transaction_id')
    custom_name_input = context.user_data.get('custom_name', "")
    if not all([plan_id, transaction_id]):
        await message.reply_text("Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø±Ø® Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§ Ù…Ø¬Ø¯Ø¯Ø§ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.", reply_markup=get_main_menu_keyboard(user_id))
        context.user_data.clear()
        return
        
    plan = db.get_plan(plan_id)
    custom_name = custom_name_input if custom_name_input else f"Ø³Ø±ÙˆÛŒØ³ {plan['gb']} Ú¯ÛŒÚ¯"
    
    msg_loading = await message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ø³Ø±ÙˆÛŒØ³ Ø´Ù…Ø§... â³", reply_markup=get_main_menu_keyboard(user_id))
    
    result = await hiddify_api.create_hiddify_user(plan['days'], plan['gb'], user_id, custom_name=custom_name)

    if result and result.get('uuid'):
        db.finalize_purchase_transaction(transaction_id, result['uuid'], result['full_link'], custom_name)
        
        referrer_id, bonus_amount = db.apply_referral_bonus(user_id)
        if referrer_id:
            try:
                await context.bot.send_message(user_id, f"ğŸ ØªØ¨Ø±ÛŒÚ©! Ù…Ø¨Ù„Øº {bonus_amount:,.0f} ØªÙˆÙ…Ø§Ù† Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù‡Ø¯ÛŒÙ‡ Ø§ÙˆÙ„ÛŒÙ† Ø®Ø±ÛŒØ¯ Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.")
                await context.bot.send_message(referrer_id, f"ğŸ‰ ØªØ¨Ø±ÛŒÚ©! ÛŒÚ©ÛŒ Ø§Ø² Ø¯ÙˆØ³ØªØ§Ù† Ø´Ù…Ø§ Ø®Ø±ÛŒØ¯ Ø®ÙˆØ¯ Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ú©Ø±Ø¯ Ùˆ Ù…Ø¨Ù„Øº {bonus_amount:,.0f} ØªÙˆÙ…Ø§Ù† Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.")
            except (Forbidden, BadRequest):
                logger.warning(f"Could not send referral bonus notification to {user_id} or {referrer_id}.")
        
        service = db.get_service_by_uuid(result['uuid'])
        if not service:
            logger.error(f"Could not find newly created service in DB (uuid: {result['uuid']}) to show link menu.")
            await msg_loading.edit_text("âŒ Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ù¾Ø³ Ø§Ø² Ø³Ø§Ø®Øª Ø³Ø±ÙˆÛŒØ³. Ù„Ø·ÙØ§Ù‹ Ø§Ø² Ù…Ù†ÙˆÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…Ù† Ø§Ù‚Ø¯Ø§Ù… Ú©Ù†ÛŒØ¯.")
            context.user_data.clear()
            return ConversationHandler.END

        try:
            await msg_loading.delete()
        except BadRequest as e:
            logger.warning(f"Could not delete 'loading' message: {e}")
            
        await show_link_options_menu(message, result['uuid'], service_id=service['service_id'], is_edit=False) 
        
    else:
        db.cancel_purchase_transaction(transaction_id)
        await msg_loading.edit_text("âŒ Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø¯Ø± Ø³Ø§Ø®Øª Ø³Ø±ÙˆÛŒØ³ Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø¢Ù…Ø¯. Ù„Ø·ÙØ§ Ø¨Ù‡ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹ Ø¯Ù‡ÛŒØ¯.")
        
    context.user_data.clear()
    return ConversationHandler.END


# ====================================================================
# ADMIN SECTION
# ====================================================================
async def admin_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ‘‘ Ø¨Ù‡ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.", reply_markup=get_admin_menu_keyboard())
    return ADMIN_MENU

async def exit_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ø´Ù…Ø§ Ø§Ø² Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯.", reply_markup=get_main_menu_keyboard(update.effective_user.id))
    return ConversationHandler.END

async def back_to_admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø§Ø²Ú¯Ø´ØªÛŒØ¯.", reply_markup=get_admin_menu_keyboard())
    return ADMIN_MENU

async def admin_delete_plan_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    plan_id = int(query.data.split('_')[-1])
    db.delete_plan(plan_id)
    await query.message.delete()
    await query.from_user.send_message("Ù¾Ù„Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯.")
    return PLAN_MENU

async def admin_toggle_plan_visibility_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    plan_id = int(query.data.split('_')[-1])
    db.toggle_plan_visibility(plan_id)
    await query.answer("ÙˆØ¶Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ Ù¾Ù„Ù† ØªØºÛŒÛŒØ± Ú©Ø±Ø¯.")
    await query.message.delete()
    await query.from_user.send_message("ÙˆØ¶Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ Ù¾Ù„Ù† ØªØºÛŒÛŒØ± Ú©Ø±Ø¯. Ø¨Ø±Ø§ÛŒ Ø¯ÛŒØ¯Ù† ØªØºÛŒÛŒØ±Ø§ØªØŒ Ù„ÛŒØ³Øª Ø±Ø§ Ù…Ø¬Ø¯Ø¯Ø§ Ø¨Ø§Ø² Ú©Ù†ÛŒØ¯.")
    return PLAN_MENU

async def admin_confirm_charge_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    prefix = "admin_confirm_charge_"
    try:
        data_part = query.data[len(prefix):]
        user_id_str, amount_str = data_part.split('_', 1)
        target_user_id = int(user_id_str)
        amount = int(float(amount_str))
    except (ValueError, IndexError) as e:
        logger.error(f"Error parsing admin_confirm_charge_callback data: {query.data} | Error: {e}")
        try:
            if query.message.photo:
                await query.edit_message_caption(caption=f"{query.message.caption}\n\n---\nâŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ú©Ù…Ù‡.")
            else:
                await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ú©Ù…Ù‡.")
        except Exception as edit_error:
            logger.error(f"Fallback error message failed to send: {edit_error}")
        return

    db.update_balance(target_user_id, amount)
    original_caption = query.message.caption or ""
    admin_feedback = f"{original_caption}\n\n---\nâœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù…Ø¨Ù„Øº {amount:,} ØªÙˆÙ…Ø§Ù† Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø± `{target_user_id}` Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯."
    
    try:
        await context.bot.send_message(
            chat_id=target_user_id, 
            text=f"Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ù…Ø¨Ù„Øº **{amount:,} ØªÙˆÙ…Ø§Ù†** Ø´Ø§Ø±Ú˜ Ø´Ø¯!", 
            parse_mode=ParseMode.MARKDOWN
        )
    except (Forbidden, BadRequest):
        admin_feedback += "\n\nâš ï¸ **Ø§Ø®Ø·Ø§Ø±:** Ú©Ø§Ø±Ø¨Ø± Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù‡ Ùˆ Ù¾ÛŒØ§Ù… ØªØ§ÛŒÛŒØ¯ Ø±Ø§ Ø¯Ø±ÛŒØ§ÙØª Ù†Ú©Ø±Ø¯."
    
    try:
        await query.edit_message_caption(caption=admin_feedback, reply_markup=None, parse_mode=ParseMode.MARKDOWN)
    except Exception as e:
        logger.error(f"edit_message_caption failed: {e}. Sending new message as fallback.")
        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_feedback, parse_mode=ParseMode.MARKDOWN)

async def admin_reject_charge_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    try:
        target_user_id = int(query.data.split('_')[-1])
    except (ValueError, IndexError) as e:
        logger.error(f"Error parsing admin_reject_charge_callback data: {query.data} | Error: {e}")
        try:
            if query.message.photo:
                await query.edit_message_caption(caption=f"{query.message.caption}\n\n---\nâŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ú©Ù…Ù‡.")
            else:
                await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ú©Ù…Ù‡.")
        except Exception as edit_error:
            logger.error(f"Fallback error message failed to send: {edit_error}")
        return

    original_caption = query.message.caption or ""
    admin_feedback = f"{original_caption}\n\n---\nâŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ø§Ø±Ú˜ Ú©Ø§Ø±Ø¨Ø± `{target_user_id}` Ø±Ø¯ Ø´Ø¯."
    
    try: 
        await context.bot.send_message(chat_id=target_user_id, text="Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ø§Ø±Ú˜ Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ† Ø±Ø¯ Ø´Ø¯.")
    except (Forbidden, BadRequest): 
        admin_feedback += "\n\nâš ï¸ **Ø§Ø®Ø·Ø§Ø±:** Ú©Ø§Ø±Ø¨Ø± Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª."
    
    try:
        await query.edit_message_caption(caption=admin_feedback, reply_markup=None, parse_mode=ParseMode.MARKDOWN)
    except Exception as e:
        logger.error(f"edit_message_caption failed: {e}. Sending new message as fallback.")
        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_feedback, parse_mode=ParseMode.MARKDOWN)

async def admin_confirm_restore_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    restore_path = context.user_data.get('restore_path')
    if not restore_path or not os.path.exists(restore_path): 
        await query.edit_message_text("Ø®Ø·Ø§: ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† ÛŒØ§ÙØª Ù†Ø´Ø¯."); 
        return BACKUP_MENU
    try:
        db.close_db()
        shutil.move(restore_path, db.DB_NAME)
        db.init_db()
        await query.edit_message_text("âœ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯.\n\n**Ù…Ù‡Ù…:** Ø¨Ø±Ø§ÛŒ Ø§Ø¹Ù…Ø§Ù„ Ú©Ø§Ù…Ù„ ØªØºÛŒÛŒØ±Ø§ØªØŒ Ù„Ø·ÙØ§Ù‹ Ø±Ø¨Ø§Øª Ø±Ø§ Ø±ÛŒâ€ŒØ§Ø³ØªØ§Ø±Øª Ú©Ù†ÛŒØ¯.", parse_mode=ParseMode.MARKDOWN)
    except Exception as e:
        logger.error(f"Error during DB restore: {e}", exc_info=True)
        await query.edit_message_text(f"Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù†Ú¯Ø§Ù… Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ ÙØ§ÛŒÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
    context.user_data.clear()
    return BACKUP_MENU

async def admin_cancel_restore_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    restore_path = context.user_data.get('restore_path')
    if restore_path and os.path.exists(restore_path): os.remove(restore_path)
    await query.edit_message_text("Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù„ØºÙˆ Ø´Ø¯.")
    context.user_data.clear()
    return BACKUP_MENU

async def plan_management_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [["â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ù„Ù† Ø¬Ø¯ÛŒØ¯", "ğŸ“‹ Ù„ÛŒØ³Øª Ù¾Ù„Ù†â€ŒÙ‡Ø§"], [BTN_BACK_TO_ADMIN_MENU]]
    await update.message.reply_text("Ø¨Ø®Ø´ Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ù„Ù†â€ŒÙ‡Ø§", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)); return PLAN_MENU

async def list_plans_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    plans = db.list_plans()
    if not plans: 
        await update.message.reply_text("Ù‡ÛŒÚ† Ù¾Ù„Ù†ÛŒ ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."); 
        return PLAN_MENU
    await update.message.reply_text("Ù„ÛŒØ³Øª Ù¾Ù„Ù†â€ŒÙ‡Ø§ÛŒ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡:")
    for plan in plans:
        visibility_icon = "ğŸ‘ï¸" if plan['is_visible'] else "ğŸ™ˆ"
        text = (f"**{plan['name']}** (ID: {plan['plan_id']})\nâ–«ï¸ Ù‚ÛŒÙ…Øª: {plan['price']:.0f} ØªÙˆÙ…Ø§Ù†\nâ–«ï¸ Ù…Ø¯Øª: {plan['days']} Ø±ÙˆØ²\nâ–«ï¸ Ø­Ø¬Ù…: {plan['gb']} Ú¯ÛŒÚ¯\nâ–«ï¸ ÙˆØ¶Ø¹ÛŒØª: {'Ù†Ù…Ø§ÛŒØ´' if plan['is_visible'] else 'Ù…Ø®ÙÛŒ'}")
        keyboard = [[InlineKeyboardButton("âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´", callback_data=f"admin_edit_plan_{plan['plan_id']}"), InlineKeyboardButton(f"{visibility_icon} ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª", callback_data=f"admin_toggle_plan_{plan['plan_id']}"), InlineKeyboardButton("ğŸ—‘ï¸ Ø­Ø°Ù", callback_data=f"admin_delete_plan_{plan['plan_id']}")]]
        await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)
    return PLAN_MENU

async def add_plan_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ù„Ø·ÙØ§ Ù†Ø§Ù… Ù¾Ù„Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:", reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True)); return PLAN_NAME

async def plan_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['plan_name'] = update.message.text
    await update.message.reply_text("Ù†Ø§Ù… Ø«Ø¨Øª Ø´Ø¯. Ù‚ÛŒÙ…Øª Ø±Ø§ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:"); return PLAN_PRICE

async def plan_price_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['plan_price'] = float(update.message.text)
        await update.message.reply_text("Ù‚ÛŒÙ…Øª Ø«Ø¨Øª Ø´Ø¯. ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:"); return PLAN_DAYS
    except ValueError: 
        await update.message.reply_text("Ù„Ø·ÙØ§ Ù‚ÛŒÙ…Øª Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return PLAN_PRICE

async def plan_days_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['plan_days'] = int(update.message.text)
        await update.message.reply_text("ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² Ø«Ø¨Øª Ø´Ø¯. Ø­Ø¬Ù… Ø³Ø±ÙˆÛŒØ³ Ø¨Ù‡ Ú¯ÛŒÚ¯Ø§Ø¨Ø§ÛŒØª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:"); return PLAN_GB
    except ValueError: 
        await update.message.reply_text("Ù„Ø·ÙØ§ ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return PLAN_DAYS

async def plan_gb_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['plan_gb'] = int(update.message.text)
        db.add_plan(context.user_data['plan_name'], context.user_data['plan_price'], context.user_data['plan_days'], context.user_data['plan_gb'])
        await update.message.reply_text("âœ… Ù¾Ù„Ù† Ø¬Ø¯ÛŒØ¯ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯!", reply_markup=get_admin_menu_keyboard())
        context.user_data.clear(); return ADMIN_MENU
    except ValueError: 
        await update.message.reply_text("Ù„Ø·ÙØ§ Ø­Ø¬Ù… Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return PLAN_GB

async def edit_plan_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    plan_id = int(query.data.split('_')[-1])
    plan = db.get_plan(plan_id)
    if not plan: 
        await query.edit_message_text("Ø®Ø·Ø§: Ù¾Ù„Ù† ÛŒØ§ÙØª Ù†Ø´Ø¯."); 
        return ConversationHandler.END
    context.user_data['edit_plan_id'] = plan_id
    context.user_data['edit_plan_data'] = {}
    await query.message.reply_text(f"Ø¯Ø± Ø­Ø§Ù„ ÙˆÛŒØ±Ø§ÛŒØ´ Ù¾Ù„Ù†: **{plan['name']}**\n\nÙ„Ø·ÙØ§ Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ø¨Ø±Ø§ÛŒ Ø±Ø¯ Ø´Ø¯Ù†ØŒ {CMD_SKIP} Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.", parse_mode=ParseMode.MARKDOWN, reply_markup=ReplyKeyboardMarkup([[CMD_SKIP],[CMD_CANCEL]], resize_keyboard=True)); return EDIT_PLAN_NAME

async def edit_plan_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['edit_plan_data']['name'] = update.message.text
    await update.message.reply_text(f"Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ø«Ø¨Øª Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÛŒØ§ {CMD_SKIP})."); return EDIT_PLAN_PRICE

async def skip_edit_plan_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"Ø§Ø² ØªØºÛŒÛŒØ± Ù†Ø§Ù… ØµØ±Ù Ù†Ø¸Ø± Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÛŒØ§ {CMD_SKIP})."); return EDIT_PLAN_PRICE

async def edit_plan_price_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['edit_plan_data']['price'] = float(update.message.text)
        await update.message.reply_text(f"Ù‚ÛŒÙ…Øª Ø¬Ø¯ÛŒØ¯ Ø«Ø¨Øª Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÛŒØ§ {CMD_SKIP})."); return EDIT_PLAN_DAYS
    except ValueError: 
        await update.message.reply_text("Ù„Ø·ÙØ§ Ù‚ÛŒÙ…Øª Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return EDIT_PLAN_PRICE

async def skip_edit_plan_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"Ø§Ø² ØªØºÛŒÛŒØ± Ù‚ÛŒÙ…Øª ØµØ±Ù Ù†Ø¸Ø± Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÛŒØ§ {CMD_SKIP})."); return EDIT_PLAN_DAYS

async def edit_plan_days_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['edit_plan_data']['days'] = int(update.message.text)
        await update.message.reply_text(f"ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² Ø¬Ø¯ÛŒØ¯ Ø«Ø¨Øª Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø­Ø¬Ù… Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ú¯ÛŒÚ¯Ø§Ø¨Ø§ÛŒØª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÛŒØ§ {CMD_SKIP})."); return EDIT_PLAN_GB
    except ValueError: 
        await update.message.reply_text("Ù„Ø·ÙØ§ ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return EDIT_PLAN_DAYS

async def skip_edit_plan_days(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"Ø§Ø² ØªØºÛŒÛŒØ± ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² ØµØ±Ù Ù†Ø¸Ø± Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø­Ø¬Ù… Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ú¯ÛŒÚ¯Ø§Ø¨Ø§ÛŒØª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (ÛŒØ§ {CMD_SKIP})."); return EDIT_PLAN_GB

async def edit_plan_gb_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['edit_plan_data']['gb'] = int(update.message.text)
        await finish_plan_edit(update, context)
        return ConversationHandler.END
    except ValueError: 
        await update.message.reply_text("Ù„Ø·ÙØ§ Ø­Ø¬Ù… Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return EDIT_PLAN_GB

async def skip_edit_plan_gb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ø§Ø² ØªØºÛŒÛŒØ± Ø­Ø¬Ù… ØµØ±Ù Ù†Ø¸Ø± Ø´Ø¯.")
    await finish_plan_edit(update, context)
    return ConversationHandler.END

async def finish_plan_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    plan_id = context.user_data.get('edit_plan_id')
    new_data = context.user_data.get('edit_plan_data')
    if not new_data: 
        await update.message.reply_text("Ù‡ÛŒÚ† ØªØºÛŒÛŒØ±ÛŒ Ø§Ø¹Ù…Ø§Ù„ Ù†Ø´Ø¯.", reply_markup=get_admin_menu_keyboard())
    else:
        db.update_plan(plan_id, new_data)
        await update.message.reply_text("âœ… Ù¾Ù„Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯!", reply_markup=get_admin_menu_keyboard())
    context.user_data.clear()
    return ADMIN_MENU

async def reports_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [["ğŸ“Š Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ", "ğŸ“ˆ Ú¯Ø²Ø§Ø±Ø´ ÙØ±ÙˆØ´ Ø§Ù…Ø±ÙˆØ²"], ["ğŸ“… Ú¯Ø²Ø§Ø±Ø´ ÙØ±ÙˆØ´ Û· Ø±ÙˆØ² Ø§Ø®ÛŒØ±", "ğŸ† Ù…Ø­Ø¨ÙˆØ¨â€ŒØªØ±ÛŒÙ† Ù¾Ù„Ù†â€ŒÙ‡Ø§"], [BTN_BACK_TO_ADMIN_MENU]]
    await update.message.reply_text("Ø¨Ø®Ø´ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ Ùˆ Ø¢Ù…Ø§Ø±", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)); return REPORTS_MENU

async def show_stats_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    stats = db.get_stats()
    text = (f"ğŸ“Š **Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ Ø±Ø¨Ø§Øª**\n\n" f"ğŸ‘¥ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: {stats.get('total_users', 0)}\n" f"âœ… ØªØ¹Ø¯Ø§Ø¯ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„: {stats.get('active_services', 0)}\n"
            f"ğŸ’° Ù…Ø¬Ù…ÙˆØ¹ ÙØ±ÙˆØ´ Ú©Ù„: {stats.get('total_revenue', 0):,.0f} ØªÙˆÙ…Ø§Ù†\n" f"ğŸš« ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ù…Ø³Ø¯ÙˆØ¯: {stats.get('banned_users', 0)}")
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN); return REPORTS_MENU

async def show_daily_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sales = db.get_sales_report(days=1)
    total_revenue = sum(s['price'] for s in sales)
    await update.message.reply_text(f"ğŸ“ˆ **Ú¯Ø²Ø§Ø±Ø´ ÙØ±ÙˆØ´ Ø§Ù…Ø±ÙˆØ²**\n\nØªØ¹Ø¯Ø§Ø¯ ÙØ±ÙˆØ´: {len(sales)}\nÙ…Ø¬Ù…ÙˆØ¹ Ø¯Ø±Ø¢Ù…Ø¯: {total_revenue:,.0f} ØªÙˆÙ…Ø§Ù†", parse_mode=ParseMode.MARKDOWN); return REPORTS_MENU

async def show_weekly_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sales = db.get_sales_report(days=7)
    total_revenue = sum(s['price'] for s in sales)
    await update.message.reply_text(f"ğŸ“… **Ú¯Ø²Ø§Ø±Ø´ ÙØ±ÙˆØ´ Û· Ø±ÙˆØ² Ø§Ø®ÛŒØ±**\n\nØªØ¹Ø¯Ø§Ø¯ ÙØ±ÙˆØ´: {len(sales)}\nÙ…Ø¬Ù…ÙˆØ¹ Ø¯Ø±Ø¢Ù…Ø¯: {total_revenue:,.0f} ØªÙˆÙ…Ø§Ù†", parse_mode=ParseMode.MARKDOWN); return REPORTS_MENU

async def show_popular_plans_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    plans = db.get_popular_plans(limit=5)
    if not plans: await update.message.reply_text("Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ† Ù¾Ù„Ù†ÛŒ ÙØ±ÙˆØ®ØªÙ‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."); return REPORTS_MENU
    text = "ğŸ† **Ù…Ø­Ø¨ÙˆØ¨â€ŒØªØ±ÛŒÙ† Ù¾Ù„Ù†â€ŒÙ‡Ø§**\n\n" + "\n".join([f"{i}. **{plan['name']}** - {plan['sales_count']} Ø¨Ø§Ø± ÙØ±ÙˆØ´" for i, plan in enumerate(plans, 1)])
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN); return REPORTS_MENU

async def settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    card_number = db.get_setting('card_number') or "ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡"
    card_holder = db.get_setting('card_holder') or "ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡"
    text = (f"âš™ï¸ **ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ø¨Ø§Øª**\n\n" f"Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª ÙØ¹Ù„ÛŒ: `{card_number}`\n" f"ØµØ§Ø­Ø¨ Ø­Ø³Ø§Ø¨ ÙØ¹Ù„ÛŒ: `{card_holder}`\n\n" "Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± Ù‡Ø± Ù…ÙˆØ±Ø¯ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ù…Ø±Ø¨ÙˆØ·Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.")
    keyboard = [[InlineKeyboardButton("ÙˆÛŒØ±Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª", callback_data="admin_edit_setting_card_number"), InlineKeyboardButton("ÙˆÛŒØ±Ø§ÛŒØ´ Ù†Ø§Ù… ØµØ§Ø­Ø¨ Ø­Ø³Ø§Ø¨", callback_data="admin_edit_setting_card_holder")]]
    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN); return ADMIN_MENU

async def edit_setting_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    setting_key = query.data.split('admin_edit_setting_')[-1]
    context.user_data['setting_to_edit'] = setting_key
    prompt_map = {'card_number': "Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:", 'card_holder': "Ù„Ø·ÙØ§ Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ ØµØ§Ø­Ø¨ Ø­Ø³Ø§Ø¨ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:"}
    prompt_text = prompt_map.get(setting_key)
    if not prompt_text: await query.message.edit_text("Ø®Ø·Ø§: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡."); return ConversationHandler.END
    await query.message.reply_text(prompt_text, reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True)); return AWAIT_SETTING_VALUE

async def setting_value_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    setting_key = context.user_data.get('setting_to_edit')
    if not setting_key: return await admin_conv_cancel(update, context)
    db.set_setting(setting_key, update.message.text)
    await update.message.reply_text("âœ… ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯.", reply_markup=get_admin_menu_keyboard())
    context.user_data.clear(); return ConversationHandler.END

async def broadcast_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [["Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", "Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ"], [BTN_BACK_TO_ADMIN_MENU]]
    await update.message.reply_text("Ø¨Ø®Ø´ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)); return BROADCAST_MENU

async def broadcast_to_all_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ù„Ø·ÙØ§ Ù¾ÛŒØ§Ù… Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:", reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True)); return BROADCAST_MESSAGE

async def broadcast_to_all_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['broadcast_message'] = update.message
    total_users = db.get_stats()['total_users']
    await update.message.reply_text(f"Ø¢ÛŒØ§ Ø§Ø² Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ† Ù¾ÛŒØ§Ù… Ø¨Ù‡ {total_users} Ú©Ø§Ø±Ø¨Ø± Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ", reply_markup=ReplyKeyboardMarkup([["Ø¨Ù„Ù‡ØŒ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†"], ["Ø®ÛŒØ±ØŒ Ù„ØºÙˆ Ú©Ù†"]], resize_keyboard=True)); return BROADCAST_CONFIRM

async def broadcast_to_all_send(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_to_send = context.user_data.get('broadcast_message')
    if not message_to_send: await update.message.reply_text("Ø®Ø·Ø§: Ù¾ÛŒØ§Ù…ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯.", reply_markup=get_admin_menu_keyboard()); return ADMIN_MENU
    user_ids = db.get_all_user_ids()
    sent_count, failed_count = 0, 0
    await update.message.reply_text(f"Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ {len(user_ids)} Ú©Ø§Ø±Ø¨Ø±...", reply_markup=get_admin_menu_keyboard())
    for user_id in user_ids:
        try: 
            await message_to_send.copy(chat_id=user_id)
            sent_count += 1
            await asyncio.sleep(0.1)
        except (Forbidden, BadRequest): 
            failed_count += 1
    await update.message.reply_text(f"âœ… Ù¾ÛŒØ§Ù… Ù‡Ù…Ú¯Ø§Ù†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.\n\nØªØ¹Ø¯Ø§Ø¯ Ø§Ø±Ø³Ø§Ù„ Ù…ÙˆÙÙ‚: {sent_count}\nØªØ¹Ø¯Ø§Ø¯ Ø§Ø±Ø³Ø§Ù„ Ù†Ø§Ù…ÙˆÙÙ‚: {failed_count}")
    context.user_data.clear(); return ADMIN_MENU

async def broadcast_to_user_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ù„Ø·ÙØ§ Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ù‡Ø¯Ù Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:", reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True)); return BROADCAST_TO_USER_ID

async def broadcast_to_user_id_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        target_id = int(update.message.text)
        context.user_data['target_user_id'] = target_id
        await update.message.reply_text("Ø¢ÛŒØ¯ÛŒ Ø«Ø¨Øª Ø´Ø¯. Ø­Ø§Ù„Ø§ Ù¾ÛŒØ§Ù…ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯:"); return BROADCAST_TO_USER_MESSAGE
    except ValueError: await update.message.reply_text("Ù„Ø·ÙØ§ ÛŒÚ© Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); return BROADCAST_TO_USER_ID

async def broadcast_to_user_message_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    target_id = context.user_data.get('target_user_id')
    if not target_id: await update.message.reply_text("Ø®Ø·Ø§: Ú©Ø§Ø±Ø¨Ø± Ù‡Ø¯Ù Ù…Ø´Ø®Øµ Ù†ÛŒØ³Øª.", reply_markup=get_admin_menu_keyboard()); return ADMIN_MENU
    message_to_send = update.message
    try:
        await message_to_send.copy(chat_id=target_id)
        await update.message.reply_text("âœ… Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.", reply_markup=get_admin_menu_keyboard())
    except (Forbidden, BadRequest): await update.message.reply_text("âŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯. Ø§Ø­ØªÙ…Ø§Ù„Ø§ Ú©Ø§Ø±Ø¨Ø± Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù‡ ÛŒØ§ Ø¢ÛŒØ¯ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª.", reply_markup=get_admin_menu_keyboard())
    context.user_data.clear(); return ADMIN_MENU

async def user_management_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ù„Ø·ÙØ§ Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ ÛŒØ§ ÛŒÙˆØ²Ø±Ù†ÛŒÙ… ØªÙ„Ú¯Ø±Ø§Ù… (Ø¨Ø§ ÛŒØ§ Ø¨Ø¯ÙˆÙ† @) Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù†ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯:", reply_markup=ReplyKeyboardMarkup([[BTN_BACK_TO_ADMIN_MENU]], resize_keyboard=True)); return MANAGE_USER_ID

async def manage_user_id_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_input = update.message.text.strip()
    user_info = None
    if user_input.isdigit(): 
        user_info = db.get_user(int(user_input))
    elif user_input.isalnum() or (user_input.startswith('@') and user_input[1:].isalnum()): 
        user_info = db.get_user_by_username(user_input)
    else: 
        await update.message.reply_text("ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ ÛŒØ§ ÛŒÙˆØ²Ø±Ù†ÛŒÙ… ØªÙ„Ú¯Ø±Ø§Ù… ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return MANAGE_USER_ID
    if not user_info: 
        await update.message.reply_text("Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù…Ø´Ø®ØµØ§Øª ÛŒØ§ÙØª Ù†Ø´Ø¯."); 
        return MANAGE_USER_ID
    context.user_data['target_user_id'] = user_info['user_id']
    ban_text = "Ø¢Ø²Ø§Ø¯ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±" if user_info['is_banned'] else "Ù…Ø³Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±"
    keyboard = [["Ø§ÙØ²Ø§ÛŒØ´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ", "Ú©Ø§Ù‡Ø´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ"], ["ğŸ“œ Ø³ÙˆØ§Ø¨Ù‚ Ø®Ø±ÛŒØ¯", ban_text], [BTN_BACK_TO_ADMIN_MENU]]
    info_text = (f"ğŸ‘¤ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±: `{user_info['user_id']}`\n" f"ğŸ”¹ ÛŒÙˆØ²Ø±Ù†ÛŒÙ…: @{user_info.get('username', 'N/A')}\n"
                 f"ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ: {user_info['balance']:.0f} ØªÙˆÙ…Ø§Ù†\n" f"ğŸš¦ ÙˆØ¶Ø¹ÛŒØª: {'Ù…Ø³Ø¯ÙˆØ¯' if user_info['is_banned'] else 'ÙØ¹Ø§Ù„'}")
    await update.message.reply_text(info_text, reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True), parse_mode=ParseMode.MARKDOWN); return MANAGE_USER_ACTION

async def manage_user_action_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    action = update.message.text
    target_user_id = context.user_data.get('target_user_id')
    if not target_user_id: 
        await update.message.reply_text("Ø®Ø·Ø§: Ú©Ø§Ø±Ø¨Ø± Ù‡Ø¯Ù Ù…Ø´Ø®Øµ Ù†ÛŒØ³Øª."); 
        return await back_to_admin_menu(update, context)
    if action in ["Ø§ÙØ²Ø§ÛŒØ´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ", "Ú©Ø§Ù‡Ø´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ"]:
        context.user_data['manage_action'] = action
        await update.message.reply_text("Ù„Ø·ÙØ§ Ù…Ø¨Ù„Øº Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø¨Ù‡ ØªÙˆÙ…Ø§Ù† ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:", reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True)); return MANAGE_USER_AMOUNT
    elif "Ù…Ø³Ø¯ÙˆØ¯" in action or "Ø¢Ø²Ø§Ø¯" in action:
        user_info = db.get_user(target_user_id)
        new_ban_status = not user_info['is_banned']
        db.set_user_ban_status(target_user_id, new_ban_status)
        await update.message.reply_text(f"âœ… ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ '{'Ù…Ø³Ø¯ÙˆØ¯' if new_ban_status else 'ÙØ¹Ø§Ù„'}' ØªØºÛŒÛŒØ± Ú©Ø±Ø¯.")
        update.message.text = str(target_user_id)
        return await manage_user_id_received(update, context)
    elif action == "ğŸ“œ Ø³ÙˆØ§Ø¨Ù‚ Ø®Ø±ÛŒØ¯":
        history = db.get_user_sales_history(target_user_id)
        if not history: 
            await update.message.reply_text("Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± ØªØ§Ú©Ù†ÙˆÙ† Ø®Ø±ÛŒØ¯ÛŒ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø§Ø³Øª."); 
            return MANAGE_USER_ACTION
        response_message = "ğŸ“œ **Ø³ÙˆØ§Ø¨Ù‚ Ø®Ø±ÛŒØ¯ Ú©Ø§Ø±Ø¨Ø±:**\n\n"
        for sale in history:
            sale_date = datetime.strptime(sale['sale_date'], '%Y-%m-%d %H:%M:%S').strftime('%Y/%m/%d - %H:%M')
            response_message += f"ğŸ”¹ **{sale['plan_name'] or 'Ù¾Ù„Ù† Ø­Ø°Ù Ø´Ø¯Ù‡'}**\n - Ù‚ÛŒÙ…Øª: {sale['price']:.0f} ØªÙˆÙ…Ø§Ù†\n - ØªØ§Ø±ÛŒØ®: {sale_date}\n\n"
        await update.message.reply_text(response_message, parse_mode=ParseMode.MARKDOWN); return MANAGE_USER_ACTION
    else: 
        await update.message.reply_text("Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."); 
        return MANAGE_USER_ACTION

async def manage_user_amount_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        amount = float(update.message.text)
        action = context.user_data['manage_action']
        target_user_id = context.user_data['target_user_id']
        is_add = True if action == "Ø§ÙØ²Ø§ÛŒØ´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ" else False
        db.update_balance(target_user_id, amount if is_add else -amount)
        await update.message.reply_text(f"âœ… Ù…Ø¨Ù„Øº {amount:.0f} ØªÙˆÙ…Ø§Ù† Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø± {'Ø§Ø¶Ø§ÙÙ‡' if is_add else 'Ú©Ø³Ø±'} Ø´Ø¯.")
        update.message.text = str(target_user_id)
        return await manage_user_id_received(update, context)
    except (ValueError, TypeError): 
        await update.message.reply_text("Ù„Ø·ÙØ§ Ù…Ø¨Ù„Øº Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯."); 
        return MANAGE_USER_AMOUNT

async def backup_restore_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [["ğŸ“¥ Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†", "ğŸ“¤ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†"], [BTN_BACK_TO_ADMIN_MENU]]
    await update.message.reply_text("Ø¨Ø®Ø´ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ.", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)); return BACKUP_MENU

async def send_backup_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M")
    backup_filename = f"backups/backup_{timestamp}.db"
    try:
        db.close_db()
        shutil.copy(db.DB_NAME, backup_filename)
        db.init_db()
        await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†...")
        await context.bot.send_document(chat_id=update.effective_user.id, document=open(backup_filename, 'rb'), caption=f"Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø¯ÛŒØªØ§Ø¨ÛŒØ³ - {timestamp}")
    except Exception as e: 
        await update.message.reply_text(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")
        logger.error(f"Backup file sending error: {e}", exc_info=True)
    finally:
        if os.path.exists(backup_filename): 
            os.remove(backup_filename)
    return BACKUP_MENU

async def restore_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"âš ï¸ **Ø§Ø®Ø·Ø§Ø±:** Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ØªÙ…Ø§Ù… Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙØ¹Ù„ÛŒ Ø±Ø§ Ù¾Ø§Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯.\n" f"Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ØŒ ÙØ§ÛŒÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ (`.db`) Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯. Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ {CMD_CANCEL} Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.", parse_mode=ParseMode.MARKDOWN); return RESTORE_UPLOAD

async def restore_receive_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    document = update.message.document
    if not document or not document.file_name.endswith('.db'): 
        await update.message.reply_text("ÙØ±Ù…Øª ÙØ§ÛŒÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ÙØ§ÛŒÙ„ `.db` Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."); 
        return RESTORE_UPLOAD
    file = await document.get_file()
    temp_path = os.path.join("backups", f"restore_temp_{datetime.now().timestamp()}.db")
    await file.download_to_drive(temp_path)
    if not is_valid_sqlite(temp_path):
        await update.message.reply_text("âŒ ÙØ§ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ÛŒ ÛŒÚ© Ø¯ÛŒØªØ§Ø¨ÛŒØ³ SQLite Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.", reply_markup=get_admin_menu_keyboard())
        if os.path.exists(temp_path): os.remove(temp_path); 
        return ADMIN_MENU
    context.user_data['restore_path'] = temp_path
    keyboard = [[InlineKeyboardButton("âœ… Ø¨Ù„Ù‡ØŒ Ù…Ø·Ù…Ø¦Ù†Ù…", callback_data="admin_confirm_restore"), InlineKeyboardButton("âŒ Ø®ÛŒØ±ØŒ Ù„ØºÙˆ Ú©Ù†", callback_data="admin_cancel_restore")]]
    await update.message.reply_text("**Ø¢ÛŒØ§ Ø§Ø² Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙØ¹Ù„ÛŒ Ú©Ø§Ù…Ù„Ø§Ù‹ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ Ø§ÛŒÙ† Ø¹Ù…Ù„ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø¨Ø§Ø²Ú¯Ø´Øª Ø§Ø³Øª.**", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN); return BACKUP_MENU

async def shutdown_bot(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ø±Ø¨Ø§Øª Ø¯Ø± Ø­Ø§Ù„ Ø®Ø§Ù…ÙˆØ´ Ø´Ø¯Ù† Ø§Ø³Øª...")
    db.close_db()
    asyncio.create_task(context.application.shutdown())

def main():
    """Start the bot."""
    db.init_db()
    application = ApplicationBuilder().token(BOT_TOKEN).build()
    job_queue = application.job_queue
    
    job_queue.run_repeating(check_low_usage, interval=timedelta(hours=4), first=10)
    job_queue.run_daily(check_expiring_services, time=time(hour=9, minute=0))

    admin_filter = filters.User(user_id=ADMIN_ID)
    user_filter = ~admin_filter
    
    buy_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(buy_start, pattern='^user_buy_')],
        states={GET_CUSTOM_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_custom_name), CommandHandler('skip', skip_custom_name)]},
        fallbacks=[CommandHandler('cancel', user_generic_cancel)],
        per_user=True, per_chat=True, per_message=False
    )
    gift_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex('^ğŸ Ú©Ø¯ Ù‡Ø¯ÛŒÙ‡$') & user_filter, gift_code_entry)],
        states={REDEEM_GIFT: [MessageHandler(filters.TEXT & ~filters.COMMAND, redeem_gift_code)]},
        fallbacks=[CommandHandler('cancel', user_generic_cancel)],
        per_user=True, per_chat=True, per_message=False
    )
    charge_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(charge_start, pattern='^user_start_charge$')],
        states={
            CHARGE_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, charge_amount_received)],
            CHARGE_RECEIPT: [MessageHandler(filters.PHOTO, charge_receipt_received)]
        },
        fallbacks=[CommandHandler('cancel', user_generic_cancel)],
        per_user=True, per_chat=True, per_message=False
    )
    settings_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(edit_setting_start, pattern="^admin_edit_setting_")],
        states={AWAIT_SETTING_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, setting_value_received)]},
        fallbacks=[CommandHandler('cancel', admin_conv_cancel)],
        per_user=True, per_chat=True,
    )
    edit_plan_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(edit_plan_start, pattern="^admin_edit_plan_")],
        states={
            EDIT_PLAN_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_plan_name_received), CommandHandler('skip', skip_edit_plan_name)],
            EDIT_PLAN_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_plan_price_received), CommandHandler('skip', skip_edit_plan_price)],
            EDIT_PLAN_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_plan_days_received), CommandHandler('skip', skip_edit_plan_days)],
            EDIT_PLAN_GB: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_plan_gb_received), CommandHandler('skip', skip_edit_plan_gb)],
        },
        fallbacks=[CommandHandler('cancel', admin_conv_cancel)],
        per_user=True, per_chat=True,
    )
    
    admin_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f'^{BTN_ADMIN_PANEL}$') & admin_filter, admin_entry)],
        states={
            ADMIN_MENU: [
                MessageHandler(filters.Regex('^â• Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ù„Ù†â€ŒÙ‡Ø§$'), plan_management_menu),
                MessageHandler(filters.Regex('^ğŸ“ˆ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ Ùˆ Ø¢Ù…Ø§Ø±$'), reports_menu),
                MessageHandler(filters.Regex('^âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª$'), settings_menu),
                MessageHandler(filters.Regex('^ğŸ’¾ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ$'), backup_restore_menu),
                MessageHandler(filters.Regex('^ğŸ“© Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…$'), broadcast_menu),
                MessageHandler(filters.Regex('^ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†$'), user_management_menu),
                MessageHandler(filters.Regex('^ğŸ›‘ Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª$'), shutdown_bot),
                CallbackQueryHandler(edit_setting_start, pattern="^admin_edit_setting_"),
            ],
            REPORTS_MENU: [
                MessageHandler(filters.Regex('^ğŸ“Š Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ$'), show_stats_report),
                MessageHandler(filters.Regex('^ğŸ“ˆ Ú¯Ø²Ø§Ø±Ø´ ÙØ±ÙˆØ´ Ø§Ù…Ø±ÙˆØ²$'), show_daily_report),
                MessageHandler(filters.Regex('^ğŸ“… Ú¯Ø²Ø§Ø±Ø´ ÙØ±ÙˆØ´ Û· Ø±ÙˆØ² Ø§Ø®ÛŒØ±$'), show_weekly_report),
                MessageHandler(filters.Regex('^ğŸ† Ù…Ø­Ø¨ÙˆØ¨â€ŒØªØ±ÛŒÙ† Ù¾Ù„Ù†â€ŒÙ‡Ø§$'), show_popular_plans_report),
                MessageHandler(filters.Regex(f'^{BTN_BACK_TO_ADMIN_MENU}$'), back_to_admin_menu),
            ],
            PLAN_MENU: [
                MessageHandler(filters.Regex('^â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ù„Ù† Ø¬Ø¯ÛŒØ¯$'), add_plan_start),
                MessageHandler(filters.Regex('^ğŸ“‹ Ù„ÛŒØ³Øª Ù¾Ù„Ù†â€ŒÙ‡Ø§$'), list_plans_admin),
                MessageHandler(filters.Regex(f'^{BTN_BACK_TO_ADMIN_MENU}$'), back_to_admin_menu),
                CallbackQueryHandler(admin_delete_plan_callback, pattern="^admin_delete_plan_"),
                CallbackQueryHandler(admin_toggle_plan_visibility_callback, pattern="^admin_toggle_plan_"),
                CallbackQueryHandler(edit_plan_start, pattern="^admin_edit_plan_")
            ],
            PLAN_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, plan_name_received)],
            PLAN_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, plan_price_received)],
            PLAN_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, plan_days_received)],
            PLAN_GB: [MessageHandler(filters.TEXT & ~filters.COMMAND, plan_gb_received)],
            MANAGE_USER_ID: [
                MessageHandler(filters.Regex(f'^{BTN_BACK_TO_ADMIN_MENU}$'), back_to_admin_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, manage_user_id_received)
            ],
            MANAGE_USER_ACTION: [
                MessageHandler(filters.Regex(f'^{BTN_BACK_TO_ADMIN_MENU}$'), back_to_admin_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, manage_user_action_handler)
            ],
            MANAGE_USER_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, manage_user_amount_received)],
            BROADCAST_MENU: [
                MessageHandler(filters.Regex('^Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†$'), broadcast_to_all_start),
                MessageHandler(filters.Regex('^Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ$'), broadcast_to_user_start),
                MessageHandler(filters.Regex(f'^{BTN_BACK_TO_ADMIN_MENU}$'), back_to_admin_menu)
            ],
            BROADCAST_MESSAGE: [MessageHandler(filters.ALL & ~filters.COMMAND, broadcast_to_all_confirm)],
            BROADCAST_CONFIRM: [MessageHandler(filters.Regex('^Ø¨Ù„Ù‡ØŒ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†$'), broadcast_to_all_send), MessageHandler(filters.Regex('^Ø®ÛŒØ±ØŒ Ù„ØºÙˆ Ú©Ù†$'), admin_generic_cancel)],
            BROADCAST_TO_USER_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_to_user_id_received)],
            BROADCAST_TO_USER_MESSAGE: [MessageHandler(filters.ALL & ~filters.COMMAND, broadcast_to_user_message_received)],
            BACKUP_MENU: [
                MessageHandler(filters.Regex('^ğŸ“¥ Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†$'), send_backup_file),
                MessageHandler(filters.Regex('^ğŸ“¤ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù†$'), restore_start),
                MessageHandler(filters.Regex(f'^{BTN_BACK_TO_ADMIN_MENU}$'), back_to_admin_menu),
                CallbackQueryHandler(admin_confirm_restore_callback, pattern="^admin_confirm_restore$"),
                CallbackQueryHandler(admin_cancel_restore_callback, pattern="^admin_cancel_restore$"),
            ],
            RESTORE_UPLOAD: [MessageHandler(filters.Document.FileExtension("db"), restore_receive_file)]
        },
        fallbacks=[
            MessageHandler(filters.Regex(f'^{BTN_EXIT_ADMIN_PANEL}$'), exit_admin_panel),
            CommandHandler('cancel', admin_generic_cancel),
        ],
        per_user=True, per_chat=True, allow_reentry=True
    )
    
    application.add_handler(charge_handler, group=1)
    application.add_handler(gift_handler, group=1)
    application.add_handler(buy_handler, group=1)
    application.add_handler(settings_conv, group=1)
    application.add_handler(edit_plan_conv, group=1)
    application.add_handler(admin_conv, group=1)
    
    application.add_handler(CallbackQueryHandler(admin_confirm_charge_callback, pattern="^admin_confirm_charge_"))
    application.add_handler(CallbackQueryHandler(admin_reject_charge_callback, pattern="^admin_reject_charge_"))
    application.add_handler(CallbackQueryHandler(check_join_callback, pattern="^check_join$"))

    # === NEW/MODIFIED HANDLERS REGISTRATION ===
    application.add_handler(CallbackQueryHandler(get_link_callback, pattern="^getlink_"), group=2)
    application.add_handler(CallbackQueryHandler(show_single_configs_menu, pattern="^single_configs_"), group=2)
    application.add_handler(CallbackQueryHandler(get_single_config, pattern="^get_single_"), group=2)
    # ========================================
    
    application.add_handler(CallbackQueryHandler(view_service_callback, pattern="^view_service_"), group=2)
    application.add_handler(CallbackQueryHandler(back_to_services_callback, pattern="^back_to_services$"), group=2)
    application.add_handler(CallbackQueryHandler(renew_service_handler, pattern="^renew_"), group=2)
    application.add_handler(CallbackQueryHandler(confirm_renewal_callback, pattern="^confirmrenew$"), group=2)
    application.add_handler(CallbackQueryHandler(cancel_renewal_callback, pattern="^cancelrenew$"), group=2)
    
    application.add_handler(CommandHandler("start", start), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ›ï¸ Ø®Ø±ÛŒØ¯ Ø³Ø±ÙˆÛŒØ³$'), buy_service_list), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ“‹ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…Ù†$'), list_my_services), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ‘¤ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø¨$'), show_account_info), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ“ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ$'), show_support), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ“š Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§ØªØµØ§Ù„$'), show_guide), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ§ª Ø¯Ø±ÛŒØ§ÙØª Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª Ø±Ø§ÛŒÚ¯Ø§Ù†$'), get_trial_service), group=3)
    application.add_handler(MessageHandler(filters.Regex('^ğŸ Ù…Ø¹Ø±ÙÛŒ Ø¯ÙˆØ³ØªØ§Ù†$'), show_referral_link), group=3)

    print("Bot is running with new features. All functions should work correctly.")
    application.run_polling()

if __name__ == "__main__":
    main()