# -*- coding: utf-8 -*-

import logging
from telegram.ext import ContextTypes, ConversationHandler
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup

import database as db
import hiddify_api
from bot.constants import GET_CUSTOM_NAME, CMD_CANCEL, CMD_SKIP
from bot.handlers import user_services as us_h

logger = logging.getLogger(__name__)

# ===== Helpers =====
def _maint_on() -> bool:
    val = db.get_setting("maintenance_enabled")
    return str(val).lower() in ("1", "true", "on", "yes")

def _maint_msg() -> str:
    return db.get_setting("maintenance_message") or "â›”ï¸ Ø±Ø¨Ø§Øª Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ú©Ù…ÛŒ Ø¨Ø¹Ø¯ Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ú©Ù†ÛŒØ¯."

# ===== Public handlers =====
async def buy_service_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if _maint_on():
        await update.message.reply_text(_maint_msg())
        return
    plans = db.list_plans(only_visible=True)
    if not plans:
        await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ù¾Ù„Ù†ÛŒ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª.")
        return
    text = "ğŸ›ï¸ Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ù¾Ù„Ù†â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
    kb = []
    for p in plans:
        title = f"{p['name']} | {p['price']:.0f} ØªÙˆÙ…Ø§Ù† | {p['days']} Ø±ÙˆØ² | {p['gb']} Ú¯ÛŒÚ¯"
        kb.append([InlineKeyboardButton(title, callback_data=f"user_buy_{p['plan_id']}")])
    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(kb))

async def buy_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    if _maint_on():
        await q.answer(_maint_msg(), show_alert=True)
        return ConversationHandler.END

    try:
        plan_id = int(q.data.split('_')[-1])
    except Exception:
        await q.answer("Ø´Ù†Ø§Ø³Ù‡ Ù¾Ù„Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.", show_alert=True)
        return ConversationHandler.END

    plan = db.get_plan(plan_id)
    if not plan or not plan.get('is_visible', 1):
        await q.answer("Ø§ÛŒÙ† Ù¾Ù„Ù† Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.", show_alert=True)
        return ConversationHandler.END

    context.user_data['buy_plan_id'] = plan_id
    try:
        await q.message.delete()
    except Exception:
        pass

    await context.bot.send_message(
        chat_id=q.from_user.id,
        text="Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ø¯Ù„Ø®ÙˆØ§Ù‡ Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒØªØ§Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\nØ¨Ø±Ø§ÛŒ Ø±Ø¯ Ø´Ø¯Ù† Ø§Ø² Ø§ÛŒÙ† Ù…Ø±Ø­Ù„Ù‡ØŒ /skip Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.",
        reply_markup=ReplyKeyboardMarkup([[CMD_CANCEL]], resize_keyboard=True)
    )
    return GET_CUSTOM_NAME

async def get_custom_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    name = (update.message.text or "").strip()
    if not name:
        await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ù†Ø§Ù… Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ÛŒØ§ /skip Ø¨Ø²Ù†ÛŒØ¯.")
        return GET_CUSTOM_NAME
    if db.get_service_by_name(update.effective_user.id, name):
        await update.message.reply_text("âš ï¸ Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ Ø³Ø±ÙˆÛŒØ³ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù†Ø§Ù… Ø¯Ø§Ø´ØªÙ‡â€ŒØ§ÛŒØ¯. Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ø¯ÛŒÚ¯Ø±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.")
        return GET_CUSTOM_NAME
    return await _process_purchase(update, context, custom_name=name)

async def skip_custom_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    return await _process_purchase(update, context, custom_name="")

async def _process_purchase(update: Update, context: ContextTypes.DEFAULT_TYPE, custom_name: str):
    user_id = update.effective_user.id
    plan_id = context.user_data.get('buy_plan_id')
    plan = db.get_plan(plan_id) if plan_id else None

    if not plan:
        await update.message.reply_text("âŒ Ù¾Ù„Ù† Ø§Ù†ØªØ®Ø§Ø¨â€ŒØ´Ø¯Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")
        context.user_data.clear()
        return ConversationHandler.END

    txn_id = db.initiate_purchase_transaction(user_id, plan_id)
    if not txn_id:
        await update.message.reply_text(
            "âŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø­Ø³Ø§Ø¨ØªØ§Ù† Ø±Ø§ Ø´Ø§Ø±Ú˜ Ú©Ù†ÛŒØ¯.",
            reply_markup=ReplyKeyboardMarkup([["ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ùˆ Ø´Ø§Ø±Ú˜"]], resize_keyboard=True)
        )
        context.user_data.clear()
        return ConversationHandler.END

    try:
        await update.message.reply_text("â³ Ø¯Ø± Ø­Ø§Ù„ Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø±ÙˆÛŒØ³ Ø´Ù…Ø§...")

        final_name = custom_name or f"Ø³Ø±ÙˆÛŒØ³ {plan['gb']} Ú¯ÛŒÚ¯"

        provision = await hiddify_api.create_hiddify_user(
            plan_days=plan['days'],
            plan_gb=plan['gb'],
            device_limit=0,
            user_telegram_id=user_id,
            custom_name=final_name
        )
        if not provision or not provision.get("uuid"):
            raise RuntimeError("Provisioning failed or no uuid returned.")

        sub_uuid = provision["uuid"]
        sub_link = ""  # Ù„ÛŒÙ†Ú© Ø¯Ø± send_service_details Ø³Ø§Ø®ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
        db.finalize_purchase_transaction(txn_id, sub_uuid, sub_link, final_name)

        svc = db.get_service_by_uuid(sub_uuid)
        if svc:
            await us_h.send_service_details(
                context=context,
                chat_id=user_id,
                service_id=svc['service_id'],
                minimal=True
            )
        else:
            await update.message.reply_text("Ø®Ø±ÛŒØ¯ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯ØŒ Ø§Ù…Ø§ Ù†Ù…Ø§ÛŒØ´ Ø³Ø±ÙˆÛŒØ³ Ø¨Ø§ Ø®Ø·Ø§ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯. Ø§Ø² Â«ğŸ“‹ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…Ù†Â» ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.")

    except Exception as e:
        logger.error("Purchase failed for user %s plan %s: %s", user_id, plan_id, e, exc_info=True)
        db.cancel_purchase_transaction(txn_id)
        await update.message.reply_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø±ÙˆÛŒØ³. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø¨Ù‡ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹ Ø¯Ù‡ÛŒØ¯.")

    context.user_data.clear()
    return ConversationHandler.END